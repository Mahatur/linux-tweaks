[---INTEL-UNDERVOLT+Suspend issue---

git clone https://github.com/kitsunyan/intel-undervolt.git
./configure && make && make install
Disable SGX, secure boot


/etc/systemd/system/intel-undervolt.service

[Unit]
Description=Apply intel-undervolt settings
After=multi-user.target suspend.target hibernate.target

[Service]
Type=oneshot
ExecStart=/usr/bin/intel-undervolt apply

[Install]
WantedBy=multi-user.target

/lib/systemd/system-sleep/99-intel-undervolt

#!/bin/sh
case $1/$2 in
  post/*)
    /usr/bin/intel-undervolt apply
    ;;
esac


sudo chmod +x /lib/systemd/system-sleep/99-intel-undervolt


---THINKPAD BATTERY INHIBIT CHARGE IF ADAPTER HAS AN ISSUE---

/usr/local/bin/ThinkSmartBat.sh

#!/bin/bash

# Configuration
BAT0_MAX=75
BAT1_MAX=75
AC_FILE="/sys/class/power_supply/AC/online"
CHECK_INTERVAL=1           # Keep 1 second for responsive AC detection
DISCONNECT_LIMIT=5
STREAK_DURATION=120
BUFFER_AFTER_INHIBIT=10
USER_HOME="/home/user"

# State variables
INHIBIT_MODE=0
PREV_AC=1
declare -a DISCONNECT_TIMES
BAT0_PRESENT=1
BAT1_PRESENT=1
THRESHOLD_APPLIED=0
CHARGE_BEHAVIOR_APPLIED=0
LAST_BAT_CHECK=0
BAT_CHECK_INTERVAL=10      # Only check battery levels every 10 seconds

# Simple debug (no timestamp parsing overhead)
debug() {
    echo "[$(date '+%H:%M:%S')] $1"
}

# Battery helpers - cache present status
check_battery_present() {
    [ -d "/sys/class/power_supply/$1" ] && \
    cat "/sys/class/power_supply/$1/capacity" &>/dev/null && echo 1 || echo 0
}

get_battery_level() {
    cat "/sys/class/power_supply/$1/capacity" 2>/dev/null || echo 0
}

# Direct writes (no sudo - service runs as root)
set_charge_behaviour() {
    local bat=$1 mode=$2
    echo "$mode" > "/sys/class/power_supply/$bat/charge_behaviour" 2>/dev/null
    debug "Set $bat charge_behaviour=$mode"
}

set_battery_thresholds() {
    local bat=$1 start=$2 end=$3
    echo "$start" > "/sys/class/power_supply/$bat/charge_control_start_threshold" 2>/dev/null
    echo "$end" > "/sys/class/power_supply/$bat/charge_control_end_threshold" 2>/dev/null
    debug "Set $bat thresholds: start=$start%, end=$end%"
}

apply_normal_charging() {
    local bat0=$(get_battery_level BAT0)
    local bat1=$(get_battery_level BAT1)
    
    if (( BAT0_PRESENT )); then
        if (( bat0 < BAT0_MAX )); then
            set_charge_behaviour BAT0 auto
        else
            set_charge_behaviour BAT0 inhibit-charge
        fi
    fi
    
    if (( BAT1_PRESENT )); then
        if (( bat1 < BAT1_MAX )); then
            set_charge_behaviour BAT1 auto
        else
            set_charge_behaviour BAT1 inhibit-charge
        fi
    fi
}

check_suspend_request() {
    local flag="/tmp/battery_suspend_request"
    [ -f "$flag" ] && {
        debug "Suspend request detected - resetting to auto"
        (( BAT0_PRESENT )) && set_charge_behaviour BAT0 auto
        (( BAT1_PRESENT )) && set_charge_behaviour BAT1 auto
        rm -f "$flag"
    }
}

# Cleanup on exit (shutdown/restart)
cleanup() {
    debug "Script stopping - resetting batteries to auto"
    (( BAT0_PRESENT )) && set_charge_behaviour BAT0 auto
    (( BAT1_PRESENT )) && set_charge_behaviour BAT1 auto
    exit 0
}

trap cleanup SIGTERM SIGINT

# Initialize batteries to auto
debug "Script starting - initializing batteries"
BAT0_PRESENT=$(check_battery_present BAT0)
BAT1_PRESENT=$(check_battery_present BAT1)
(( BAT0_PRESENT )) && set_charge_behaviour BAT0 auto
(( BAT1_PRESENT )) && set_charge_behaviour BAT1 auto

# Main loop
while true; do
    # Fast AC detection (every second)
    AC_ON=$(cat "$AC_FILE" 2>/dev/null || echo 0)
    CURRENT_TIME=$(date +%s)
    
    # Periodic checks
    check_suspend_request
    
    # Skip if no batteries present
    if (( BAT0_PRESENT == 0 && BAT1_PRESENT == 0 )); then
        sleep $CHECK_INTERVAL
        continue
    fi
    
    # Handle AC state change (FAST - no optimization here)
    if (( AC_ON != PREV_AC )); then
        debug "AC state: $PREV_AC → $AC_ON | Disconnects: ${#DISCONNECT_TIMES[@]} | Inhibit: $INHIBIT_MODE"
        
        if (( AC_ON == 0 )); then
            # AC unplugged
            if (( INHIBIT_MODE == 1 )); then
                debug "Manual unplug during inhibit → reset"
                INHIBIT_MODE=0
                DISCONNECT_TIMES=()
            elif (( ${#DISCONNECT_TIMES[@]} < DISCONNECT_LIMIT )); then
                DISCONNECT_TIMES+=($CURRENT_TIME)
                debug "Disconnect #${#DISCONNECT_TIMES[@]} recorded"
            fi
            THRESHOLD_APPLIED=0
            CHARGE_BEHAVIOR_APPLIED=0
            
        else
            # AC plugged
            if (( ${#DISCONNECT_TIMES[@]} >= DISCONNECT_LIMIT && INHIBIT_MODE == 0 )); then
                debug "Replugged after limit → reset streak"
                DISCONNECT_TIMES=()
            fi
            
            # Set thresholds once
            if (( THRESHOLD_APPLIED == 0 )); then
                (( BAT0_PRESENT )) && set_battery_thresholds BAT0 0 $BAT0_MAX
                (( BAT1_PRESENT )) && set_battery_thresholds BAT1 0 $BAT1_MAX
                THRESHOLD_APPLIED=1
            fi
            
            # Apply charging behavior once
            if (( CHARGE_BEHAVIOR_APPLIED == 0 && INHIBIT_MODE == 0 )); then
                apply_normal_charging
                CHARGE_BEHAVIOR_APPLIED=1
            fi
        fi
        PREV_AC=$AC_ON
    fi
    
    # Check disconnect streak expiration
    if (( ${#DISCONNECT_TIMES[@]} > 0 && INHIBIT_MODE == 0 )); then
        ELAPSED=$(( CURRENT_TIME - DISCONNECT_TIMES[0] ))
        if (( ELAPSED > STREAK_DURATION )); then
            debug "Disconnect streak expired → reset"
            DISCONNECT_TIMES=()
        fi
    fi
    
    # Check for inhibition trigger
    if (( INHIBIT_MODE == 0 && ${#DISCONNECT_TIMES[@]} >= DISCONNECT_LIMIT )); then
        debug "Disconnect limit reached → INHIBIT MODE"
        (( BAT0_PRESENT )) && set_charge_behaviour BAT0 inhibit-charge
        (( BAT1_PRESENT )) && set_charge_behaviour BAT1 inhibit-charge
        INHIBIT_MODE=1
    fi
    
    # Optimized: Only re-check battery levels every 10 seconds (not every second)
    if (( INHIBIT_MODE == 0 && AC_ON == 1 && CHARGE_BEHAVIOR_APPLIED == 1 )); then
        if (( CURRENT_TIME - LAST_BAT_CHECK >= BAT_CHECK_INTERVAL )); then
            apply_normal_charging
            LAST_BAT_CHECK=$CURRENT_TIME
        fi
    fi
    
    sleep $CHECK_INTERVAL
done



---SERVICE---

[Unit]
Description=ThinkSmartBat Battery Monitor
After=suspend.target

[Service]
Type=simple
ExecStart=/usr/local/bin/ThinkSmartBat.sh
KillMode=mixed
KillSignal=SIGTERM
TimeoutStopSec=5
Restart=on-failure

[Install]
WantedBy=suspend.target

]

[SLUGGISH SUSPEND OR SHUTDOWN

/usr/lib/systemd/system-sleep/battery-reset-on-suspend.sh
sudo chmod +x /usr/lib/systemd/system-sleep/battery-reset-on-suspend.sh

#!/bin/bash

BAT0_PATH="/sys/class/power_supply/BAT0"
BAT1_PATH="/sys/class/power_supply/BAT1"

case "$1/$2" in
    pre/suspend|pre/hibernate)
        # Before suspend/hibernate - reset to auto so they charge while suspended
        echo "Battery Manager: Resetting batteries to auto before suspend"
        [ -d "$BAT0_PATH" ] && echo "auto" > "$BAT0_PATH/charge_behaviour" 2>/dev/null
        [ -d "$BAT1_PATH" ] && echo "auto" > "$BAT1_PATH/charge_behaviour" 2>/dev/null
        ;;
    post/suspend|post/hibernate)
        # After resume - let the main script take over
        echo "Battery Manager: System resumed, main script will handle charging"
        ;;
esac

]
