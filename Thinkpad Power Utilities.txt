[---INTEL-UNDERVOLT+Suspend issue---

git clone https://github.com/kitsunyan/intel-undervolt.git
./configure && make && make install
Disable SGX, secure boot


/etc/systemd/system/intel-undervolt.service

[Unit]
Description=Apply intel-undervolt settings
After=multi-user.target suspend.target hibernate.target

[Service]
Type=oneshot
ExecStart=/usr/bin/intel-undervolt apply

[Install]
WantedBy=multi-user.target

/lib/systemd/system-sleep/99-intel-undervolt

#!/bin/sh
case $1/$2 in
  post/*)
    /usr/bin/intel-undervolt apply
    ;;
esac


sudo chmod +x /lib/systemd/system-sleep/99-intel-undervolt
]

[---POWER-LIMITER, SHORTCUT ONLY---

Epowersave

#!/bin/bash

STATE_FILE="/tmp/powersave_click"

# Functions
set_ultra_powersave() {
    sudo cpupower frequency-set -g powersave -d 400MHz -u 3000MHz
    echo 1 | sudo tee /sys/class/powercap/intel-rapl:0/constraint_0_time_window_us > /dev/null
    echo 1 | sudo tee /sys/class/powercap/intel-rapl:0/constraint_1_time_window_us > /dev/null
    echo 3500000 | sudo tee /sys/class/powercap/intel-rapl:0/constraint_0_power_limit_uw >/dev/null
    echo 3500000 | sudo tee /sys/class/powercap/intel-rapl:0/constraint_1_power_limit_uw >/dev/null
    notify-send "Ultra Powersave Mode" "3.5 Watt power"
}

set_emergency_powersave() {
    sudo cpupower frequency-set -g powersave -d 400MHz -u 3000MHz
    echo 1 | sudo tee /sys/class/powercap/intel-rapl:0/constraint_0_time_window_us > /dev/null
    echo 1 | sudo tee /sys/class/powercap/intel-rapl:0/constraint_1_time_window_us > /dev/null
    echo 1000000 | sudo tee /sys/class/powercap/intel-rapl:0/constraint_0_power_limit_uw >/dev/null
    echo 1000000 | sudo tee /sys/class/powercap/intel-rapl:0/constraint_1_power_limit_uw >/dev/null
    notify-send "Emergency Powersave Mode" "1 Watt power"
}

# Handle click logic
if [ -f "$STATE_FILE" ]; then
    last_click=$(cat "$STATE_FILE" 2>/dev/null || echo 0)
    now=$(date +%s)
    
    if [ $((now - last_click)) -le 1 ]; then
        # Double execute → Emergency Powersave
        rm -f "$STATE_FILE"
        set_emergency_powersave
        exit 0
    fi
fi

# Single execute → Ultra Powersave
date +%s > "$STATE_FILE"
set_ultra_powersave

# Clean up state file after delay
(sleep 1 && rm -f "$STATE_FILE") &

exit 0






Powersave

sudo cpupower frequency-set -g powersave -d 400MHz -u 3000MHz
echo 1 | sudo tee /sys/class/powercap/intel-rapl:0/constraint_0_time_window_us > /dev/null
echo 1 | sudo tee /sys/class/powercap/intel-rapl:0/constraint_1_time_window_us > /dev/null
echo 7000000 | sudo tee /sys/class/powercap/intel-rapl:0/constraint_0_power_limit_uw
echo 7000000 | sudo tee /sys/class/powercap/intel-rapl:0/constraint_1_power_limit_uw
notify-send "Powersave Mode" "7 Watt power"


Performance

#!/bin/bash

STATE_FILE="/tmp/turbo_boost_click"
ENERGY_FILE="/sys/class/powercap/intel-rapl:0/energy_uj"
POWER0="/sys/class/powercap/intel-rapl:0/constraint_0_power_limit_uw"
POWER1="/sys/class/powercap/intel-rapl:0/constraint_1_power_limit_uw"

# Functions
set_15w() {
    sudo cpupower frequency-set -g performance -d 400MHz -u 3000MHz
    echo 15000000 | sudo tee $POWER0 $POWER1 >/dev/null
    echo 1 | sudo tee /sys/class/powercap/intel-rapl:0/constraint_0_time_window_us > /dev/null
    echo 1 | sudo tee /sys/class/powercap/intel-rapl:0/constraint_1_time_window_us > /dev/null
    notify-send "Performance mode" "Set to 15 Watt power"
}

set_30w() {
    sudo cpupower frequency-set -g performance -d 400MHz -u 3000MHz
    echo 30000000 | sudo tee $POWER0 $POWER1 >/dev/null
    echo 100000000000 | sudo tee /sys/class/powercap/intel-rapl:0/constraint_0_time_window_us > /dev/null
    echo 100000000000 | sudo tee /sys/class/powercap/intel-rapl:0/constraint_1_time_window_us > /dev/null

    notify-send "PREPARE FOR CPU BURNING!!!!" "30 Watt Power temporary!!"
}

get_power() {
    # Read energy counter with sudo (since files are root-only)
    local e1=$(sudo cat "$ENERGY_FILE" 2>/dev/null || echo 0)
    sleep 1
    local e2=$(sudo cat "$ENERGY_FILE" 2>/dev/null || echo 0)
    
    # Handle counter overflow or invalid readings
    if [ "$e1" -eq 0 ] || [ "$e2" -eq 0 ] || [ "$e2" -lt "$e1" ]; then
        echo 0
        return
    fi
    
    echo $(( (e2 - e1) / 1000000 ))  # µJ/s → W
}

turbo_monitor() {
    # Store PID for cleanup
    echo $$ > "$TURBO_PID_FILE"
    
    # Wait a bit before starting monitoring to avoid immediate fallback
    sleep 1
    
    local consecutive_low=0
    
    while true; do
        watts=$(get_power)
        
        # Only count valid power readings
        if [ "$watts" -gt 0 ]; then
            if [ "$watts" -lt 16 ]; then
                consecutive_low=$((consecutive_low + 1))
                # Require 3 consecutive low readings to avoid false triggers
                if [ "$consecutive_low" -ge 3 ]; then
                    set_15w
                    # Clean up
                    rm -f "$TURBO_PID_FILE"
                    exit 0
                fi
            else
                consecutive_low=0
            fi
        fi
        
        # Check every 2 seconds instead of every 1 second for better stability
        sleep 1
    done
}

# Kill any existing turbo monitor
if [ -f "$TURBO_PID_FILE" ]; then
    old_pid=$(cat "$TURBO_PID_FILE" 2>/dev/null)
    if [ -n "$old_pid" ] && kill -0 "$old_pid" 2>/dev/null; then
        kill "$old_pid" 2>/dev/null
        notify-send "Turbo cancelled" "Previous turbo mode stopped"
    fi
    rm -f "$TURBO_PID_FILE"
fi

# Handle click logic
if [ -f "$STATE_FILE" ]; then
    last_click=$(cat "$STATE_FILE" 2>/dev/null || echo 0)
    now=$(date +%s)
    
    if [ $((now - last_click)) -le 1 ]; then
        # Double click → turbo mode
        rm -f "$STATE_FILE"
        set_30w
        
        # Start turbo monitor in background
        turbo_monitor &
        exit 0
    fi
fi

# Single click → set to 15W
date +%s > "$STATE_FILE"
set_15w

# Clean up state file after delay
(sleep 1 && rm -f "$STATE_FILE") &

exit 0

]




[ ---THINKPAD BATTERY INHIBIT CHARGE IF ADAPTER HAS AN ISSUE---

/usr/local/bin/ThinkSmartBat.sh

#!/bin/bash

# Configuration
BAT0_MAX=75
BAT1_MAX=75
AC_FILE="/sys/class/power_supply/AC/online"
CHECK_INTERVAL=1           # Keep 1 second for responsive AC detection
DISCONNECT_LIMIT=5
STREAK_DURATION=120
BUFFER_AFTER_INHIBIT=10
USER_HOME="/home/user"

# State variables
INHIBIT_MODE=0
PREV_AC=1
declare -a DISCONNECT_TIMES
BAT0_PRESENT=1
BAT1_PRESENT=1
THRESHOLD_APPLIED=0
CHARGE_BEHAVIOR_APPLIED=0
LAST_BAT_CHECK=0
BAT_CHECK_INTERVAL=10      # Only check battery levels every 10 seconds

# Simple debug (no timestamp parsing overhead)
debug() {
    echo "[$(date '+%H:%M:%S')] $1"
}

# Battery helpers - cache present status
check_battery_present() {
    [ -d "/sys/class/power_supply/$1" ] && \
    cat "/sys/class/power_supply/$1/capacity" &>/dev/null && echo 1 || echo 0
}

get_battery_level() {
    cat "/sys/class/power_supply/$1/capacity" 2>/dev/null || echo 0
}

# Direct writes (no sudo - service runs as root)
set_charge_behaviour() {
    local bat=$1 mode=$2
    echo "$mode" > "/sys/class/power_supply/$bat/charge_behaviour" 2>/dev/null
    debug "Set $bat charge_behaviour=$mode"
}

set_battery_thresholds() {
    local bat=$1 start=$2 end=$3
    echo "$start" > "/sys/class/power_supply/$bat/charge_control_start_threshold" 2>/dev/null
    echo "$end" > "/sys/class/power_supply/$bat/charge_control_end_threshold" 2>/dev/null
    debug "Set $bat thresholds: start=$start%, end=$end%"
}

apply_normal_charging() {
    local bat0=$(get_battery_level BAT0)
    local bat1=$(get_battery_level BAT1)
    
    if (( BAT0_PRESENT )); then
        if (( bat0 < BAT0_MAX )); then
            set_charge_behaviour BAT0 auto
        else
            set_charge_behaviour BAT0 inhibit-charge
        fi
    fi
    
    if (( BAT1_PRESENT )); then
        if (( bat1 < BAT1_MAX )); then
            set_charge_behaviour BAT1 auto
        else
            set_charge_behaviour BAT1 inhibit-charge
        fi
    fi
}

check_suspend_request() {
    local flag="/tmp/battery_suspend_request"
    [ -f "$flag" ] && {
        debug "Suspend request detected - resetting to auto"
        (( BAT0_PRESENT )) && set_charge_behaviour BAT0 auto
        (( BAT1_PRESENT )) && set_charge_behaviour BAT1 auto
        rm -f "$flag"
    }
}

# Cleanup on exit (shutdown/restart)
cleanup() {
    debug "Script stopping - resetting batteries to auto"
    (( BAT0_PRESENT )) && set_charge_behaviour BAT0 auto
    (( BAT1_PRESENT )) && set_charge_behaviour BAT1 auto
    exit 0
}

trap cleanup SIGTERM SIGINT

# Initialize batteries to auto
debug "Script starting - initializing batteries"
BAT0_PRESENT=$(check_battery_present BAT0)
BAT1_PRESENT=$(check_battery_present BAT1)
(( BAT0_PRESENT )) && set_charge_behaviour BAT0 auto
(( BAT1_PRESENT )) && set_charge_behaviour BAT1 auto

# Main loop
while true; do
    # Fast AC detection (every second)
    AC_ON=$(cat "$AC_FILE" 2>/dev/null || echo 0)
    CURRENT_TIME=$(date +%s)
    
    # Periodic checks
    check_suspend_request
    
    # Skip if no batteries present
    if (( BAT0_PRESENT == 0 && BAT1_PRESENT == 0 )); then
        sleep $CHECK_INTERVAL
        continue
    fi
    
    # Handle AC state change (FAST - no optimization here)
    if (( AC_ON != PREV_AC )); then
        debug "AC state: $PREV_AC → $AC_ON | Disconnects: ${#DISCONNECT_TIMES[@]} | Inhibit: $INHIBIT_MODE"
        
        if (( AC_ON == 0 )); then
            # AC unplugged
            if (( INHIBIT_MODE == 1 )); then
                debug "Manual unplug during inhibit → reset"
                INHIBIT_MODE=0
                DISCONNECT_TIMES=()
            elif (( ${#DISCONNECT_TIMES[@]} < DISCONNECT_LIMIT )); then
                DISCONNECT_TIMES+=($CURRENT_TIME)
                debug "Disconnect #${#DISCONNECT_TIMES[@]} recorded"
            fi
            THRESHOLD_APPLIED=0
            CHARGE_BEHAVIOR_APPLIED=0
            
        else
            # AC plugged
            if (( ${#DISCONNECT_TIMES[@]} >= DISCONNECT_LIMIT && INHIBIT_MODE == 0 )); then
                debug "Replugged after limit → reset streak"
                DISCONNECT_TIMES=()
            fi
            
            # Set thresholds once
            if (( THRESHOLD_APPLIED == 0 )); then
                (( BAT0_PRESENT )) && set_battery_thresholds BAT0 0 $BAT0_MAX
                (( BAT1_PRESENT )) && set_battery_thresholds BAT1 0 $BAT1_MAX
                THRESHOLD_APPLIED=1
            fi
            
            # Apply charging behavior once
            if (( CHARGE_BEHAVIOR_APPLIED == 0 && INHIBIT_MODE == 0 )); then
                apply_normal_charging
                CHARGE_BEHAVIOR_APPLIED=1
            fi
        fi
        PREV_AC=$AC_ON
    fi
    
    # Check disconnect streak expiration
    if (( ${#DISCONNECT_TIMES[@]} > 0 && INHIBIT_MODE == 0 )); then
        ELAPSED=$(( CURRENT_TIME - DISCONNECT_TIMES[0] ))
        if (( ELAPSED > STREAK_DURATION )); then
            debug "Disconnect streak expired → reset"
            DISCONNECT_TIMES=()
        fi
    fi
    
    # Check for inhibition trigger
    if (( INHIBIT_MODE == 0 && ${#DISCONNECT_TIMES[@]} >= DISCONNECT_LIMIT )); then
        debug "Disconnect limit reached → INHIBIT MODE"
        (( BAT0_PRESENT )) && set_charge_behaviour BAT0 inhibit-charge
        (( BAT1_PRESENT )) && set_charge_behaviour BAT1 inhibit-charge
        INHIBIT_MODE=1
    fi
    
    # Optimized: Only re-check battery levels every 10 seconds (not every second)
    if (( INHIBIT_MODE == 0 && AC_ON == 1 && CHARGE_BEHAVIOR_APPLIED == 1 )); then
        if (( CURRENT_TIME - LAST_BAT_CHECK >= BAT_CHECK_INTERVAL )); then
            apply_normal_charging
            LAST_BAT_CHECK=$CURRENT_TIME
        fi
    fi
    
    sleep $CHECK_INTERVAL
done



---SERVICE---

[Unit]
Description=ThinkSmartBat Battery Monitor
After=suspend.target

[Service]
Type=simple
ExecStart=/usr/local/bin/ThinkSmartBat.sh
KillMode=mixed
KillSignal=SIGTERM
TimeoutStopSec=5
Restart=on-failure

[Install]
WantedBy=suspend.target

]

[SLUGGISH SUSPEND OR SHUTDOWN

/usr/lib/systemd/system-sleep/battery-reset-on-suspend.sh
sudo chmod +x /usr/lib/systemd/system-sleep/battery-reset-on-suspend.sh

#!/bin/bash

BAT0_PATH="/sys/class/power_supply/BAT0"
BAT1_PATH="/sys/class/power_supply/BAT1"

case "$1/$2" in
    pre/suspend|pre/hibernate)
        # Before suspend/hibernate - reset to auto so they charge while suspended
        echo "Battery Manager: Resetting batteries to auto before suspend"
        [ -d "$BAT0_PATH" ] && echo "auto" > "$BAT0_PATH/charge_behaviour" 2>/dev/null
        [ -d "$BAT1_PATH" ] && echo "auto" > "$BAT1_PATH/charge_behaviour" 2>/dev/null
        ;;
    post/suspend|post/hibernate)
        # After resume - let the main script take over
        echo "Battery Manager: System resumed, main script will handle charging"
        ;;
esac

]
